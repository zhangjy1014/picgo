# 	Ch6_存储管理



[toc]



左书目录：
引言—存储器的层次结构与管理目的

一、存储管理功能

二、内存资源管理

三、存储管理方式

四、外存空间管理

五、虚拟存储系统





## **基本概念**

### **存储器的层次结构**

**==种类==：**
​	1. 高速缓存(Cache)		少量、快、贵

​	2. 内存(RAM)				  储存量若干、中等速度、中等价格、易变

​	3. 磁盘							  量大、低速、廉价、不易变

由操作系统协调这些存储器的使用。

**==内存==：**是由存储单元（字节或字）组成的一维连续的地址空间，简称**内存空间**。用来存放当前正在运行程序的代码及数据，是程序中指令本身地址所指的，亦即程序计数器所指的存储器。

分为：系统区：用于存放操作系统
		   用户区：用于装入并存放用户程序和数据

### **存储器管理的目的**

1、充分利用内存，为多道程序并发执行提供存储基础。
2、尽可能方便用户使用。
​	自动装入用户程序
​	用户程序中不必考虑硬件细节
3、系统能够解决程序空间比实际内存空间大的问题。
4、程序在执行时可以动态伸缩；即动态链接
5、内存存取速度快；
6、存储保护与安全；
7、共享与通信；
8、了解有关资源的使用情况；
9、实现性价比。

### **存储管理的功能（5大）**

#### 存储分配

存储的分配与回收：

记录内存的使用情况——设置相应的内存分配表（内存分配回收的依据）即已经分配的区域

​								 	——设置相应的空闲表（内存回收的依据）即尚未分配的区域

**虚拟存储管理的系统中，内存和外存各需要一个分配表，一个空闲表。

步骤：

​	1.确定分配算法

​	2.实施内存分配

​	3.回收内存	方式：静态分配和动态分配

#### 存储共享

概念：两个或多个进程共用内存中相同的区域。

目的：节省内存，提高内存效率、相互通讯（数据共享）

内容：代码共享要求代码为**纯代码**（运行过程中不会修改自身）、数据共享

#### 存储保护

类别：防止地址越界、防止操作越界

**目的**：为多个程序共享内存提供保障，使在内存中的各道程序，只能访问它自己的区域，避免各道程序间相互干扰，特别是当一道程序发生错误时，不至于影响其它程序的运行。通常**由硬件完成保护功能，由软件辅助实现**。

**过程**：每个进程都有自己独立的进程空间，如果一个进程在运行时所产生的地址在其地址空间之外，**则发生地址越界**。**即**当进程要访问某个内存单元时，由硬件检查是否允许，如果允许则执行，否则产生地址越界中断，由操作系统进行相应处理。

硬件提供一对寄存器：基址寄存器、限长寄存器

#### 存储扩充

–内存、外存结合，形成虚拟存储体系

–速度接近内存，容量相当外存

实现方式：1. 通过虚拟存储技术实现。内存、外存结合，形成虚拟存储体系

​					2. 用户在编制程序时，不应该受内存容量限制，所以要采用一定的技术来“扩充”内存容量，使用户得到比实际内存容量大得多的内存空间。速度接近内存，容量相当外存。

请求分页（虚拟页式），请求分段（虚拟段式），虚拟段页式

#### 地址映射（地址重定位、地址变换）

逻辑地址->物理地址

硬件支持：基址寄存器(base)、限长寄存器(limit)、快表

需软硬件结合完成。

### **补充概念**

#### 内存空间（物理空间）

内存是由若干个存储单元组成的，每个存储单元有一个编号，这种编号可唯一标识一个存储单元，成为**内存地址**（物理地址）。

#### 逻辑空间

1）用汇编语言或高级语言编写程序时，常常用符号名来访问某一存储单元，我们把程序中由符号名组成的程序空间称为**符号名空间**，简称名空间。

2）源程序经过编译后形成目标程序，每个程序都是以0为基址顺序进行编址，原来用符号名访问的单元用具体的数据----单元号，这样生成的目标程序占据一定的地址空间，成为作业的**逻辑地址空间**，简称**逻辑空间**。逻辑空间中要访问的操作数地址统称为逻辑地址。

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530161021769.png" alt="image-20220530161021769" style="zoom:33%;" />

多道程序环境下，要使程序运行，必须创建进程，而创建进程的第一件事就是将程序和数据装入内存。一个用户源程序要变为在内存中可执行的程序，通常要进行以下处理：

（1）**编译：**由编译程序将用户源程序编译成若干个**目标**模块

（2）**链接：**由链接程序将目标模块和相应的库函数链接成**装入**模块，就是所谓链接为可执行模块

（3）**装入**：由装入程序将装入模块装入内存。即意味着运行

由于用户的逻辑地址空间都是从0开始的，而当该程序装入**内存运行**时又不是从0开始，因此就需要将逻辑地址转换成实际的内存地址。

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530161359359.png" alt="image-20220530161359359" style="zoom:43%;" />

#### 装入

==1、绝对装入（单道）==

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530163031104.png" alt="image-20220530163031104" style="zoom:50%;" />

==2、静态重定位装入（多道）==

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530163156326.png" alt="image-20220530163156326" style="zoom:50%;" />

==3、动态重定位装入（多道）==

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530163232806.png" alt="image-20220530163232806" style="zoom:50%;" />

对比：

绝对装入方式只能将装入模块装入到内存中事先指定的位置，在多道程序环境下是不可能事先知道每一道程序在内存中的位置的，因此这种装入方式只能用于单道程序环境。

地址转换时机：程序中所使用的绝对地址，既可在编译或汇编时给出，也可由程序员直接赋予。适用于单道环境。

可重定位装入方式可将装入模块装入到内存中任何允许的位置，故可用于多道程序环境；然而它不允许程序在运行中移动位置。地址转换时机发生于程序装入内存时发生。

动态运行时装入方式允许程序在运行中移动位置，需要特殊硬件的支持。地址转换时机发生于程序运行时。

#### 链接

**静态链接**

静态链接实在生成可执行文件时进行的。是一种事先链接方式，即在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装入模块(执行文件)，以后不再拆开。

缺点：（1）不便于对目标模块的修改和更新

​			（2）无法实现对目标模块的共享

**动态链接**（装入时动态链接、运行时动态链接）

优点：共享动态链接库(DLL)、部分装入、便于局部代码修改、便于运行环境适应

==装入时动态链接==：将一组目标模块在装入内存时，边*装入边链接*的方式。具有便于修改和更新、便于实现对目标模块的共享。

由于程序运行所有可能用的目标模块在装入时均全部链接在一起，所以将会把一些不会运行的目标模块也链接进去。如程序中的错误处理模块。

==运行时动态链接==：在程序**真正**运行中需要某些目标模块时，才对它们进行链接的方式。具有高效且节省内存空间的优点。



## **内存划分和分配**

### 内存的划分

按分区时刻：==静态==（系统初始化时就划分，一般分配空间的要大雨进程所需要的）、==动态==（进程申请时划分，一般按照进程所需大小分配恰好满足要求的区域）

按分区大小：等长（将存储空间划分成长度相同的区域）、异长（按照程序、程序单位、对象大小，分为长度不同的区域）

通常划分方法：静态等长（页式、段页式）；动态异长（段式、界地址~起始地址和长度，称作一个对界，一维连续地址~）

### 内存的分配

#### 静态等长分区分配

常用于页式、段页式存储管理。存储空间静态分为若干个长度相等的区域，称作一个页面。每个页面长*2^i^B*

①==将整个系统的内存空间==划分成一系列**大小相等的块**，每一块称为一个**物理块**、**物理页**或**实页**，**页架**或**页帧（frame）**，可简称为**块（block）**。所有的块按物理地址递增顺序连续编号为0、1、2、……。
这里的块相当于饭店的客房，系统对内存分块相当于饭店把大楼所有的客房都设计成标准的双人间。

②==每个作业的地址空间==也划分成一系列与内存块一样大小的块，每一块称为一个**逻辑页**或**虚页**，也有人叫**页面**，可简称为**页（page）**。所有的页按照逻辑地址递增顺序连续编号为0、1、2、……。
这里，对作业地址空间分页就相当于把旅游团成员分成两人一组。

算法

- 位示图

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530192227221.png" alt="image-20220530192227221" style="zoom:33%;" />

- 空闲页面表

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530192341734.png" alt="image-20220530192341734" style="zoom:33%;" />

- 空闲页面链

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530192353101.png" alt="image-20220530192353101" style="zoom:33%;" />

#### 动态异长分区分配

  **存储空间被动态的划分为若干长度不等的区域，根据请求的大小比较分配。**

算法

- 最先适应

算法：

1.先将空闲分区（链）按==地址递增==的次序排列。

2.进行内存分配时,从空闲分区表/链首开始顺序查找,直到找到第一个满足其大小要求的空闲分区为止。

3.再按照作业大小，从该分区中划出一块内存空间分配给请求者，**余下的空闲**分区仍留在空闲分区表（链）中。

优点：优先利用内存低地址部分的空闲分区，保留高地址部分的大空闲区。

缺点：低地址部分被不断划分，导致低地址端留下很多碎片空闲区
		    每次查找均需要从低地址部分开始，增加了查找可用空闲分区的开销

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530195729837.png" alt="image-20220530195729837" style="zoom:33%;" />

- 循环首次适应

算法：1.先将空闲分区（链）按==地址递增==的次序排列。
			2.每次为进程分配内存空间时，不是从链首**开始**，而是**==从上次找到的空闲分区的下一个空闲分区开始查找==**，直到找到一个满足要求的空闲分区。

优点：使存储空间的利用更加均衡，不让小的空闲区集中在存储区的一段

缺点：可能会缺乏大的空闲区

- 最佳适应

算法：1.算法要求空闲分区表/链按**容量**大小递增的次序排列。（==空闲区长度==）
		    2.内存分配时，从空闲分区表/链的首开始顺序查找，直到找到第一个满足其大小要求的空闲分区为止。

优点：若存在与作业大小一致的空闲分区，则必被选中

​			若不存在大小一致的分区，则只划分比作业稍大的空闲分区，从而保留了大的分区。

缺点：由于空闲区一般不可能正好和它申请的内存大小一样，因而将其分割为两部分时，往往使剩下的空闲区非常小，从而==容易在存储器中留下碎片==。

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530200644248.png" alt="image-20220530200644248" style="zoom:33%;" />

- 最坏适应

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530200801637.png" alt="image-20220530200801637" style="zoom:33%;" />

### 碎片处理

碎片：动态异长分区存储分配使可能产生的很小的空闲区域。

紧凑/拼凑：移动占用区域，使所有空闲区域连成一片。

需要移动内存

## **基本存储管理**

### 单一连续管理（界地址管理）（一维地址）

基本原理：连续分配方式：一个进程分配一个连续的存储空间。

确定一个进程在内存空间地址的两个参数：起始地址、长度（一个对界），也叫单对界存储管理方式

1. 内存空间的划分：动态异长

2. 进程空间的划分：一个进程一个区域，逻辑地址$0$～$l-1$ 。

3. 进程空间与内存空间的对应关系可以浮动

   <img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530202257729.png" alt="image-20220530202257729" style="zoom:40%;" />

4. 所需表目：

   1. 内存分配表--PCB中，记录已经分配的区域
   2. 空闲区域表--记录内存中尚未分配的区域

5. 所需寄存器：

   1. 基址寄存器：整个系统一个，保存正在运行进程的起始地址
   2. 限长寄存器：整个系统一个，保存正在运行进程的长度

6. 地址映射：地址映射将程序所产生的逻辑地址变换为内存中的物理地址。

$𝛿：(a) -> (b+a) ∪{Ω}$

其中$a$为逻辑地址，$b$为进程起始（**首**）地址. 当*a*所对应的物理地址**不存在**时(**越界**)，映射没有意义，结果为$Ω$. 

### 基本页式管理(分页式存储管理)

分页式存储管理就是要实现从逻辑地址空间到物理地址空间到一种变换，

​															$f: L→S$ 

其中，$L、S$分别表示逻辑地址空间和物理地址空间  

==页架/框==：把物理内存空间划分为若干个等份，每一份叫做一个页架。

==页面==：把用户程序按页架划分成大小相等的部分，称为页面。从0开始编制页号，页内地址相对于0编址。

1. 内存空间的划分：静态等长，2^i^，成为一个页架

   <img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530210222735.png" alt="image-20220530210222735" style="zoom: 50%;" />

2. 进程空间的划分：静态等长，2^i^，成为一个页面

   <img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530210348259.png" alt="image-20220530210348259" style="zoom:50%;" />

3. 内存空间到进程空间对应

   <img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530210509416.png" alt="image-20220530210509416" style="zoom:50%;" />

4. 所需表：

   1. 页表，每个进程一个，存放于内存。
   2. 总页表，系统一个，记录页框的使用情况，即空闲页面表

5. 所需寄存器

   1. 页表首址寄存器：系统一个

   2. 页表长度寄存器：系统一个

   3. 快表：系统一组。页表太大时，慢。因此引入快表。将正在访问页面所对应的项目记录于快表中。访问页面时，先根据逻辑页号在快表中查找，找到，则根据页框号和页内地址形成物理地址；没找到，则由逻辑地址在页表中查找，并将找到的页框号与逻辑页号放在快表中。**快表是寄存器**

      | 逻辑页号 | 页架号 |
      | :------- | :----- |
      | ...      | ...    |
      | p        | f      |
      |          |        |

6. 地址映射

   逻辑地址$(p,d)$- >物理地址$(f,d)$ 	 	$𝛿：(p,d) -> (f,d) ∪{Ω}$

在进程执行过程中，由硬件地址分页结构自动将每条程序指令中的逻辑地址解释成两部分，即页号p和页内地址w。通过页号查询页表得到页架号b，b与页内地址w合成物理地址，然后通过物理地址访问内存。

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220619212618560.png" alt="image-20220619212618560" style="zoom:50%;" />

<img src="/Users/zhangjy/Downloads/IMG_6389.jpg" alt="IMG_6389" style="zoom:33%;" />



### 基本段式管理（分段式存储管理）

1. 内存空间划分：动态异长，每区一段 					 物理地址=段首址+段内地址
2. 进程空间划分：若干段，每段一个程序单位。       逻辑地址=段号|段内地址 （二维地址）

​	确定段的段号和段内地址，必须知道所有的段号和段内地址才行。因为每段的大小不同。

3. 对应关系

   <img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530220340285.png" alt="image-20220530220340285" style="zoom: 33%;" />

 4. 所需表

    	1. 段表：**每进程一个，**存放于内存**，段表里是每一段首址，这点和页表不同，页表放的是页架号**
        	2. 空闲区域表：系统一个

    <img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530220443954.png" alt="image-20220530220443954" style="zoom: 33%;" />

5. 所需寄存器

   1. 段表首址寄存器：b 系统一个

   2. 段表长度寄存器： l 系统一个

   3. 快表：系统一组

      | 段号 | 段首址 | 段长度 |
      | ---- | ------ | ------ |
      | ...  | ...    | ...    |
      | s    | b'     | l'     |
      | ...  | ...    | ...    |
      |      |        |        |

6. 地址映射		

     <img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530220712976.png" alt="image-20220530220712976" style="zoom: 33%;" />
     <img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220619213746875.png" alt="image-20220619213746875" style="zoom:50%;" />
     
     <img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220621093931163.png" alt="image-20220621093931163" style="zoom:33%;" />

分段和分页的区别

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220531161642758.png" alt="image-20220531161642758" style="zoom:50%;" />

### 段页式存储管理

原理：先将程序按内在逻辑关系分成若干大小不一定相等的段，并将这些段再细分为若干页进行内存分配，即==先分段，再分页==。

对内存空间：分为大小相等的页；

对用户程序：分成若干段，每个段分成若干页，地址结构：段号(S)|段内页号(P)|页内地址(D)

优点：可以使内碎片更小，非常好的解决了内存碎片问题；便于动态链接

1. 内存空间划分（同页式）：静态等长，2^i^，成为一个页	物理地址=(页架号，页内地址)=($f,d$)

2. 进程空间的划分： 一个进程<-->若干段 ；一个段<-->若干页；    逻辑地址=(段号，逻辑页号，页内地址)=$(s, p, d)$

3. 对应关系

   <img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220531162827212.png" alt="image-20220531162827212" style="zoom:50%;" />

4. 所需表：

   <img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220531162913591.png" alt="image-20220531162913591" style="zoom:50%;" />

5. 所需寄存器：

   1. 段表基址寄存器：保存正运行程序段表首址； b

   2. 段表限长寄存器：保存正运行程序段表长度； l

   3. 快表：快段表+快页表

      | 段号 | 逻辑页号 | 页架号 |
      | ---- | -------- | ------ |
      | ...  | ...      | ...    |
      | s    | p        | f      |
      | ...  | ...      | ...    |

6. 地址映射

   <img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220531163213810.png" alt="image-20220531163213810" style="zoom: 33%;" />
   
   <img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220621094036232.png" alt="image-20220621094036232" style="zoom:33%;" />

### 交换与覆盖

交换：换入/换出；滚入/滚出。  进程内存空间与外存空间的交换（动态调度）

覆盖：把程序划分为若干个功能上相对独立的程序段，按照程序的逻辑结构让那些不会同时执行的程序共享一块内存区。当有关程序段的先头程序执行结束后，在后继程序段调入内存覆盖前面的程序段。

​			**将全局代码和数据静态地放在内存，其它部分则分阶段地动态装入**。覆盖是部分装入的。是将较大程序装入较小进程空间的一种技术。

交换与覆盖都是内存扩充的技术

### 内碎片与外碎片

**内碎片**:是指*页面内部*没有被使用的存储区域,在页式存储方式中,会出现内碎片。 

**外碎片**:是指没有得到分配权的存储区域,在段式存储方式中,会产生外碎片

### 快表

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220530215103993.png" alt="image-20220530215103993" style="zoom:33%;" />

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220531161517246.png" alt="image-20220531161517246" style="zoom:33%;" />



### 段表

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220531161157203.png" alt="image-20220531161157203" style="zoom:33%;" />

## **虚存**

### **虚存的知识**

#### 外存管理（交换区）

##### 基本概念

外存空间：磁盘等存储设备上的存储区域		分为：Swap空间、File空间、输入井、输出井

外存空间的划分：静态等长，$2^i$，成为一块，块是外存分配的基本单位，也是IO传输的基本单位，物理块。

外存空间分配（与内存类似）：位示图、空闲块表、空闲块链

##### 进程空间与外存空间的对应关系

- 界地址
  	每进程占一组外存连续块（单对界）
  	每进程占二组外存连续块（双对界，程序，代码）。
- 页式
      内存一页，外存一块；一个进程可在外存占多个不连续的块。内存页和外存块，大小一样
- 段式
      每段占外存若干连续块。一个进程的多段放在外存的不同区域。
- 段页式
      内存一页，外存一块。一个进程的多段放在外存的不同区域。

==局部性原理==：指程序在执行时呈现出局部性规律，即在一较短时间内，程序的执行仅限于某个部分，相应地，它所访问的存储空间也局限于某个区域。局部性原理是实现虚拟存储器的理论基础。

==时间局部性==：如果程序中的某条指令一旦执行，则不久的将来该指令可能再次被执行；如果某个存储单元被访问，则不久以后该存储单元可能再次被访问。产生时间局限性的典型原因是在程序中存在着大量的循环操作。如循环执行。

==空间局部性==：一旦程序访问了某个存储单元，则在不久的将来，其附近的存储单元也最有可能被访问。即程序在一段时间内所访问的地址，可能集中在一定的范围内，其典型原因是程序是顺序执行的。如顺序执行。

### **虚存管理**

#### 基本知识

虚存基本性质

==部分装入==：在程序装入时，不必将其全部读入到内存，而只需将当前需要执行的部分页或段读入到内存，就可让程序开始执行。

==缺页/段则请调==：在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页或段调入到内存，然后继续执行程序。

==内存不够则置换/淘汰==：操作系统将内存中暂时不使用的页或段调出保存在外存上，从而腾出空间存放将要装入的程序以及将要调入的页或段。只需程序的一部分在内存就可执行。

虚存性质

==多次性==：一个作业被分成多次调入内存运行

==对换性==：允许在作业的运行过程中进行换入、换出

==虚拟性==：能从逻辑上扩充内存容量，使用户“看到”的内存容量远大于实际大小（基于前两特征）

#### 请求页式（虚拟页式存储系统）

基本原理：运行前，全部装入外存，部分内存；运行时，若缺页，则请调，内存够，则调入，内存不够，则置换

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220531195005447.png" alt="image-20220531195005447" style="zoom: 34%;" />

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220531195538721.png" alt="image-20220531195538721" style="zoom:50%;" />

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220531195625620.png" alt="image-20220531195625620" style="zoom:50%;" />

缺页中断机构

在请求分页系统中，每当所要访问的页面不在内存时，便要产生一缺页中断，请求OS将所缺页调入内存。

与一般中断的区别（3点）：

- 缺页中断在==指令执行期间==产生和处理中断信号，而一般中断在==一条指令执行完后==检查和处理中断处理信号。
- 缺页中断返回到指令的开始==重新执行该指令==，而一般中断返回到==该指令的下一条指令==执行
- 一条指令在执行期间，可能产生==多次缺页中断==。

内存页框分配策略

1. 平均分配：每个进程分配相同的页面
2. 按进程长度比例分配
3. 按进程优先级比例分配，高优先级多，低少
4. 按进程长度和优先级别比例分配

缺点：1.程序结构；不同进程的页面局部性不同  2. 程序在不同时刻的行为不同，进程对页面来说是动态的。

外存块的分配策略

1. 静态分配：一个进程在运行前，将所有页面全部装入外存，当一个外存页面被调入内存，所占用的外存页面不释放。外存保持全部页面。
   优点：速度快，淘汰不必写回     缺点：外存浪费
2. 动态分配：一个进程运行前，仅将没有装入内存的部分装入外存，当某页面被调入内存时，释放所占用的外存空间。外存进保持进程不在内存的页面。
   优点：节省外存    缺点：速度慢--淘汰必写回

页面调入时机

1. 请调，请求调页策略：当进程在运行中发生缺页时，就立即提出请求，由系统将缺页调入内存。
2. 预调，预调页策略：主动的缺页调入策略，将那些预计不久后会被访问的程序或数据所在的页面预先调入内存。

​	*预调必须辅以请调。

#### ==页面置换算法==

1. 最佳淘汰算法(OPT-optimal)：选择**未来不再使用**或**离当前位置最远** 的页面，被置换。难以实现。
2. 先进先出(FIFO)：选择建立最早的页面被置换，可通过链表方式表示各页的建立先后。**淘汰最先调入的**。实现方式：队列
3. 最近最少（久）使用算法(LRU)：选择内存中最久未使用的页面置换。**淘汰最近一次访问距当前时间最长的**。
   因为要记录先后关系，硬件开销大。
   方法：计时法、堆栈法
4. 最近不用的先淘汰(not used recently)：**近似于**LR算法，不但希望淘汰最近未使用的页面，还希望被挑选的页面在内存驻留期间，其页面内容没有给修改过，因此增加两个硬件位：访问位和修改位。0和1，0表示未访问或未修改。
5. 二次机会算法(second chance)：淘汰老的而且最近没用的页面。使用链表，新来的放表尾，表头是老的(同FIFO)。表头R=0则淘汰，R=1则将R置0然后放到表尾。
6. 时钟算法：用环型链表实现二次机会算法。==遇到1则清0，遇到0则淘汰==
7. 改进的时钟算法：添加一个m项，被修改过m=1,未被修改m=0。

#### 请求段式

<img src="/Users/zhangjy/Library/Application Support/typora-user-images/image-20220531211134151.png" alt="image-20220531211134151" style="zoom:50%;" />
